diff --git a/compiler/rustc_mir_transform/src/lib.rs b/compiler/rustc_mir_transform/src/lib.rs
index e590a80b441..588af3ef4e5 100644
--- a/compiler/rustc_mir_transform/src/lib.rs
+++ b/compiler/rustc_mir_transform/src/lib.rs
@@ -95,7 +95,6 @@
 mod prettify;
 mod promote_consts;
 mod ref_prop;
-mod remove_gc_drops;
 mod remove_noop_landing_pads;
 mod remove_storage_markers;
 mod remove_uninit_drops;
@@ -617,7 +616,6 @@ fn o1<T>(x: T) -> WithMinOptLevel<T> {
             &deduplicate_blocks::DeduplicateBlocks,
             &large_enums::EnumSizeOpt { discrepancy: 128 },
             // Must come before CriticalCallEdges to prevent LLVM basic block ordering errors.
-            &remove_gc_drops::RemoveGcDrops,
             // Some cleanup necessary at least for LLVM and potentially other codegen backends.
             &add_call_guards::CriticalCallEdges,
             // Cleanup for human readability, off by default.
diff --git a/compiler/rustc_mir_transform/src/remove_gc_drops.rs b/compiler/rustc_mir_transform/src/remove_gc_drops.rs
deleted file mode 100644
index 2dacc12137f..00000000000
--- a/compiler/rustc_mir_transform/src/remove_gc_drops.rs
+++ /dev/null
@@ -1,43 +0,0 @@
-use rustc_middle::mir::*;
-use rustc_middle::ty::{self, TyCtxt};
-use rustc_span::sym;
-
-use super::simplify::simplify_cfg;
-
-pub struct RemoveGcDrops;
-
-impl<'tcx> MirPass<'tcx> for RemoveGcDrops {
-    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {
-        trace!("Running RemoveGcDrops on {:?}", body.source);
-
-        let is_gc_crate = tcx
-            .get_diagnostic_item(sym::gc)
-            .map_or(false, |gc| gc.krate == body.source.def_id().krate);
-
-        let did = body.source.def_id();
-        let param_env = tcx.param_env_reveal_all_normalized(did);
-        let mut should_simplify = false;
-
-        for block in body.basic_blocks.as_mut() {
-            let terminator = block.terminator_mut();
-            if let TerminatorKind::Drop { place, target, .. } = terminator.kind {
-                let ty = place.ty(&body.local_decls, tcx).ty;
-                if !ty.is_gc(tcx) {
-                    continue;
-                }
-
-                if let ty::Adt(_, substs) = ty.kind() {
-                    if is_gc_crate || !substs.type_at(0).needs_finalizer(tcx, param_env) {
-                        terminator.kind = TerminatorKind::Goto { target };
-                        should_simplify = true;
-                    }
-                }
-            }
-        }
-        // if we applied optimizations, we potentially have some cfg to cleanup to
-        // make it easier for further passes
-        if should_simplify {
-            simplify_cfg(body);
-        }
-    }
-}
diff --git a/library/std/src/gc.rs b/library/std/src/gc.rs
index f11d75cb503..3a30bda6718 100644
--- a/library/std/src/gc.rs
+++ b/library/std/src/gc.rs
@@ -245,32 +245,6 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Gc<U>> for Gc<T> {}
 #[unstable(feature = "gc", issue = "none")]
 impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Gc<U>> for Gc<T> {}
 
-/// A compiler barrier to prevent finalizers running before the last reference to
-/// an object is dead.
-///
-/// The compiler is free to optimise away the stack or register location holding
-/// a GC reference if it's no longer used. This means that sometimes, at
-/// runtime, a reference is cleaned up earlier than its source-level lifetime to
-/// free up the register for something else. This is fine (and usually
-/// desirable!) because it doesn't have any observable difference in behaviour.
-///
-/// However, things get complicated when a garbage collector is involved. In
-/// very rare cases, this optimisation, followed by an unfortunately timed
-/// collection, may cause the value the reference points to to be freed earlier
-/// than expected - and thus finalized earlier than it should be. This can cause
-/// deadlocks, races, and even use-after-frees.
-///
-/// Adding a compiler barrier to `Gc`'s drop prevents the compiler from optimizing
-/// away the reference too soon. This is a special implementation with compiler
-/// support, because it is usually impossible to allow both `Drop` and `Copy`
-/// traits to be implemented on a type simultaneously.
-#[cfg(all(not(bootstrap), not(test)))]
-impl<T: ?Sized> Drop for Gc<T> {
-    fn drop(&mut self) {
-        keep_alive(self);
-    }
-}
-
 impl<T: ?Sized> Gc<T> {
     #[inline(always)]
     fn inner(&self) -> &GcBox<T> {
@@ -413,7 +387,7 @@ pub unsafe fn new_unsynchronised(value: T) -> Self {
     #[cfg(not(no_global_oom_handling))]
     unsafe fn new_internal(value: T) -> Self {
         #[cfg(not(bootstrap))]
-        if !crate::mem::needs_finalizer::<T>() {
+        if !crate::mem::needs_drop::<T>() {
             return Self::from_inner(Box::leak(Box::new_in(GcBox { value }, GcAllocator)).into());
         }
 
